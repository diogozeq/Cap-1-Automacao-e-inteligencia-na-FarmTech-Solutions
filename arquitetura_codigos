import os
import argparse

def get_tree_structure(startpath, output_file=None):
    output_lines = []
    last_file_path = ""

    # Certifica-se de que startpath é um caminho absoluto
    startpath = os.path.abspath(startpath)

    for root, dirs, files in os.walk(startpath, topdown=True):
        level = root.replace(startpath, '').count(os.sep)
        # Se for o diretório raiz, não adicione a barra, a menos que seja o próprio diretório base.
        # Para o diretório raiz, a indentação deve ser diferente.
        if root == startpath:
            output_lines.append(f'{os.path.basename(root)}/')
        else:
            indent = '│   ' * level
            output_lines.append(f'{indent}├── {os.path.basename(root)}/')

        sub_indent = '│   ' * (level + 1)

        for f in sorted(files):
            file_path = os.path.join(root, f)
            last_file_path = os.path.abspath(file_path)

            output_lines.append(f'{sub_indent}├── {f}')

    output_lines.append(last_file_path)

    full_output = '\n'.join(output_lines)
    if output_file:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(full_output)
        print(f'Estrutura e conteúdo salvos em: {output_file}')
    else:
        print(full_output)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Gera uma representação textual da estrutura de pastas e arquivos.')
    # Torna o argumento 'path' opcional, com valor padrão '.' (diretório atual)
    parser.add_argument('path', type=str, nargs='?', default='.', help='O caminho da pasta a ser analisada (padrão: diretório atual).')
    parser.add_argument('--output', type=str, help='Caminho para o arquivo de saída (opcional).')

    args = parser.parse_args()

    get_tree_structure(args.path, args.output)